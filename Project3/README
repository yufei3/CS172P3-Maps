Name: Yufei Zhao
NetID: yzhao87
CSC172 Project3
No lab partners

Content: Intersection.java, StreetMap.java, In.java, Road.java, Graph.java, Canvas.java, README, OUTPUT, and three map files. 

In.java is a file created by others. 

The StreetMap class contains the main method. To see the output, you need to type the things you want to know in the format mentioned in Proj3 Requirement. 

Some obstacles are understanding the logic of Dijkstra and Kruskal algorithms and making them work for my Graph. And initially, I used lots of ArrayLists to store my data. However, the access of element in the ArrayLists really costs so much time, especially in nys map. So I then changed some ArrayLists to HashTable or HashMap. The runtime decreases a lot. Besides, since we have several different situations to deal with, I need to display different set of things on the canvas. At first I did not how to separate the case but paint the map in the paintComponent method. Finally I found the way. 

Runtime analysis: 
There are three parts in the whole project. 

The first part is about painting the map or getting Intersections and Roads of the map. This step takes O(n) in my main method. I go through all the data in the txt file (let the number of intersections and roads to be n). Adding intersections and roads to corresponding arraylists takes O(1) runtime. Adding each intersection to the hashMap dictionary takes O(1) runtime. Adding the other intersection to the ArrayList neighbors of one intersection takes O(1) runtime. Calculating the distance/weight of a road takes O(1) runtime. To sum up, it is O(n) runtime to create a new map with intersections and roads provided in file. My idea of calculating the weight of roads and getting the neighbors of intersections is to improve runtime. Here I only takes tiny time to gather such information. But if in other loops, I may take much more time to get the information.To paint the map, if required, I need to go through all the roads. Painting one line needs O(1). If there are n roads, O(n) runtime to paint all the roads. Since I need to first get the information and then paint, the runtime is about O(n)+O(n)=O(n). When the data sets get larger, I simply need more time to read the intersections and roads and create a map with these information. 

The second part is to find the shortest path between two intersections. For the following analysis, V stands for the number of intersections, and E stands for the number edges/roads. The major method to do this is Dijkstra method. Determining whether the HashMap contains the starting intersection take O(1). Assigning initial distance and known variables takes O(V) as we need to go through all the intersections. Larger data sets here need more time. Simple assignments takes O(1). Adding the first element into the Priority Queue takes relatively tiny time.  For the while loop, PriorityQueue.remove() takes O(log E) time; set.add(u) takes O(1) time; and we look at evaluatingNeighbors method. In the method evaluatingNeighbors, there are at most E intersections as neighbors with totally E roads. Hashset.contains(v) takes O(1) time; simple assignments takes O(1) time; PriorityQueue.add(v) takes O(log E). Hence the runtime for evaluatingNeighbors is at most O(ElogE). Then the total runtime for while loop is O(logE+ElogE)=O(ElogE). To sum up, for the whole Dijkstra method, the runtime is O(V+ElogE). For larger data sets, each intersections may have more neighbors to check, which taks longer time. After I generate the shortest path, I apply another method directionPath to get a list of the intersection on this shortest path. This takes O(n) runtime: To find the corresponding intersections with the IntersectionID need O(n) time; since there are at most E roads between two connected intersections, adding E intersections to the pathList requires O(E). Painting takes at most O(n) runtime as well. 

The third part is to get the minimum spanning tree of the map. The major method for this part is Kruskal, with the help of find and union. For the following analysis, V stands for the number of intersections, and E stands for the number edges/roads. In the Kruskal method, adding E roads into the PriorityQueue takes O(ElogE). Generating the Hashmap with V pairs of an intersection and its parent requires O(V). The runtime for find method is about O(1), with worst case O(V), since HashMap.get(vertex) for vertex's parent and the comparison both take only O(1) time. The worst case is when we need to go through the entire intersections to find the parent for each intersection. Here the worst case in find method hurts larger data sets more. Union method takes about the same runtime with find method, since runtime<union> ~ 2*runtime<find>. So, the while loop runs about V times and takes O(V). Totally, the runtime is O(ElogE+V+V)=O(ElogE). 

Generally, plotting map is about O(n); Dijkstra is about O(V+ElogE); Kruskal is about O(ElogE). 